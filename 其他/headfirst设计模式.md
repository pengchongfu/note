## 观察者模式
定义了对象之间的一对多依赖。依赖者会收到通知自动更新

## 装饰器模式
动态地将责任附加到对象上。想要扩展功能，装饰者提供有别于继承的另一种选择。
（类似于 http 中间件的调用栈）

## 工厂模式
提供一个接口，创建相关或依赖对象的家族，而不需要明确指定具体类。
（为多个调用方提供唯一生成对象的入口）

## 单例模式
确保一个类只有一个实例，并提供全局访问

## 命令模式
将请求封装成对象，这可以让你使用不同的请求，队列或者日志请求来参数化其他对象。命令模式也可以支持撤销操作

## 适配器模式
- 适配器模式：将一个类的接口，转化为客户所期望的另一个接口
（提供兼容层）
- 外观模式：提供高层接口，屏蔽内部接口

## 模板方法
在一个方法中定义算法骨架，而将一些步骤延迟到子类中。在不改变算法结构的情况下，重新定义某些步骤
（sort 的 len less swap 接口）

## 迭代器和组合模式
- 迭代器模式：顺序访问元素，隐藏内部实现（数据，map，树）
- 组合模式：树形结构，允许客户以一致的方法处理个别对象和对象组合

## 状态模式
允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类
（状态机）

## 代理模式
为另一个对象提供一个替身或占位符以访问这个对象
- 虚拟代理：实例化开销大的话，可以延迟实例化（图片懒加载）
- 保护代理：基于调用者控制对象方法的访问
- 同步代理：多线程下提供安全访问（简单的线程安全map）
- 缓存代理，防火墙代理

## 复合模式：模式的模式
- MVC

## 与设计模式相处
