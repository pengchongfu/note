## 6.1 资源
在进程对设备、文件取得了排他性访问权时，有可能出现死锁
资源就是随着时间推移，必须能够获得、使用以及释放的任何东西

### 6.1.1 可抢占资源和不可抢占资源
可抢占资源：可以从拥有它的进程中抢占而不会产生任何副作用
不可抢占资源：比如CD刻录机

死锁和不可抢占资源有关，有关可抢占资源的潜在的死锁可以通过在进程之间重新分配资源而化解。

### 6.1.2 资源获取
- 为每个资源配置一个信号量，初始化为1，down操作来获取资源，up操作释放资源

## 6.2 死锁概述
如果一个进程集合中的每个进程都在等待只能由该进程集合中的其他进程才能引发的事件，那么，该进程集合就是死锁的。

### 6.2.1 资源死锁的条件
1. 互斥条件，每个资源要么被分配，要么可用
2. 占有和等待条件，已经得到某个资源的进程可以再请求其他资源
3. 不可抢占条件，已经分配给一个进程的资源不能强制性地被抢占，只能占有它的进程显式释放
4. 环路等待条件，死锁发生时，系统中一定有两个或两个以上的进程组成的一条环路，环路中每个进程都在等待下一个进程占有的资源

### 6.2.2 死锁建模
可以用有向图建模

四种处理死锁的策略：
1. 忽略
2. 检查死锁并恢复，（如何恢复）
3. 动态地避免死锁
4. 破坏四个必要条件之一

## 6.3 鸵鸟算法
把头埋到沙子里

## 6.4 死锁检测和恢复

### 6.4.1 每种类型一个资源的死锁检测
检测有向图环路的算法

### 6.4.2 每种类型多个资源的死锁检测
矩阵向量。。。

### 6.4.3 从死锁中恢复
1. 利用抢占恢复，让不可抢占资源变成可抢占的，可能需要手动操作
2. 利用回滚恢复，将进程的状态写入一个文件以备重启，重启之后分配给一个死锁进程
3. 通过杀死重启
    - 杀掉环中进程
    - 杀掉环外进程（因为坏外的资源有可能被环中进程请求，比如两个打印机中的一台）
    - 最好杀死可以从头开始运行却没有副作用的进程

## 6.5 死锁避免
存在算法可以避免死锁

### 6.5.1 资源轨迹图
根据资源轨迹图在请求资源时由操作系统挂起

### 6.5.2 安全状态和不安全状态
安全状态：从安全状态出发，系统能够保证所有进程都能完成

### 6.5.3 单个资源的银行家算法
### 6.5.4 多个资源的银行家算法
很有意义但是缺乏实用价值，因为很少进程能够在运行前就知道所需资源的最大值

## 6.6 死锁预防
### 6.6.1 破坏互斥条件
### 6.6.2 破坏占有和等待条件
开始执行前请求所有资源
（运行时才知道所需资源）
### 6.6.3 破坏不可抢占条件
### 6.6.4 破坏环路等待条件
1. 只能占用一个资源（不可行啊）
2. 对资源编号，升序请求

|条件|处理方式|
|---|---|
|互斥|一切使用假脱机技术|
|占有和等待|开始就请求全部资源|
|不可抢占|抢占资源|
|环路等待|对资源按序编号|

## 6.7 其他问题

### 6.7.1 两阶段加锁
第一阶段加锁，第二阶段执行
第一阶段加锁失败就释放

不通用，因为很多资源获取了不能中途释放

### 6.7.2 通信死锁
两个进程通信，B阻塞，A发送消息阻塞等待回复，消息丢失
并非经典的资源死锁

通过超时解决
通信系统也可能发生资源死锁：路由器环路

### 6.7.3 活锁
忙等待导致的活锁

### 6.7.4 饥饿
与活锁非常相似

比如进程优先级，由于优先级太低永远得不到时间片

通过先来先服务可以避免