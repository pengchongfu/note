## 进程
一个进程就是一个正在执行程序的实例，包括程序计数器、寄存器和变量的当前值。
一个进程是某种类型的一个活动，它有程序、输入、输出以及状态。

fork之后但在execve之前允许该子进程处理其文件描述符，这样可以完成对标准输入、标准输出和标准出错的重定向。

进程的3种状态：运行态、就绪态和阻塞态
进程表项：程序计数器、堆栈指针、内存分配状况、所打开文件状态、账号、调度信息，以及其他在进程由运行态转换到就绪态或者阻塞态时必须保存的信息。对应进程管理、存储管理和文件管理三类。

中断发生后操作系统最底层的工作步骤：
1. 硬件压入堆栈程序计数器等；
2. 硬件从中断向量装入新的程序计数器；
3. 汇编语言过程保存寄存器值；
4. 汇编语言过程设置新的堆栈；
5. C中断服务例程运行（读和缓冲输入）；
6. 调度程序决定下一个将运行的进程；
7. C过程返回至汇编代码；
8. 汇编语言过程开始运行新的当前进程；

## 线程

同一个地址空间中准并行运行多个控制线程。

需要多线程原因：
- 多进程模型具有不同的地址空间，有局限。
- 并且创建和撤销线程开销比较小。
- 若存在IO处理可以提高性能。
- 多CPU系统中，多线程是有益的。

多线程使得顺序进程的思想得以保留下来，这种顺序进程阻塞了系统调用，但是仍然实现了并行性。

|模型|特性|
|---|---|
|多线程|并行性 阻塞系统调用|
|单线程|无并行性 阻塞系统调用|
|有限状态机|并行性 非阻塞系统调用 中断|

进程用于把资源集中在一起，线程则是在CPU上被调度执行的实体。

### 在用户空间中实现线程

每个进程需要有其专用的线程表。需要一个运行时系统。允许进程有自己定制的调度算法。

明显的问题：如何实现阻塞系统调用？
方案一：select系统调用，用以确保不会阻塞才进行下一步系统调用

进程内部没有时间中断，无法进行轮转调度

### 在内核中实现线程

创建和撤销线程的代价比较大，采用回收线程的方式。
问题：信号应该交由谁处理？

### 混合实现

内核级线程与用户级线程多路复用。每个内核级线程有一个可以轮流使用的用户级线程集合。

## 进程间通信

#### 竞争条件

两个或多个进程读写某些共享数据，而最后的结果取决于运行的精确时序，称为竞争条件。

解决方案：实现互斥，阻止多个进程同时读写共享的数据。

临界区：共享内存的程序片段。

好的解决方案：
- 任何两个进程不能同时处于临界区
- 不对CPU速度和数量做任何假设
- 临界区外的进程不得阻塞其他进程
- 不得使进程无期限等待进入临界区

1. 屏蔽中断
    - 将该权力交给用户进程不明智
    - 多CPU依旧可以访问共享内存
2. 锁变量
    - 无效
3. 严格轮换法
    - 只有认为等待时间非常短才用忙等待，用于忙等待的锁称为自旋锁
    - 违反了条件3
4. Peterson解法
5. TSL指令

### 睡眠与唤醒

4和5都是正确的，但是都有忙等待的缺点。有可能出现优先级反转问题。

生产者-消费者问题，使用sleep和wakeup系统调用（pipe？）

### 信号量

原子操作是指一组相关联的操作要么都不间断地执行，要不都不执行。

检查数值，修改变量值以及可能发生的睡眠操作均作为一个单一的、不可分割的原子操作完成。

实现：在执行以下操作时暂时屏蔽全部中断：测试信号量、更新信号量以及在需要时使某个进程睡眠

### 互斥量

不需要信号量的计数能力，可以使用简化版本互斥量。

### 管程

死锁问题

sleep和wakeup存在严重的竞争条件是因为当一个进程想睡眠时另一个进程试图去唤醒它。

信号量太低级了，管程在少数几种编程语言之外无法使用，需要其他方法

### 消息传递

### 屏障

## 调度

### 调度介绍

CPU密集型进程和IO密集型进程

根据如何处理时钟中断，可以把调度算法分为两类：
- 非抢占式：时钟中断发生，不会进行调度
- 抢占式

调度算法分类
- 批处理：非抢占式
- 交互式：抢占式
- 实时：可信任，非抢占式

指标：
- 吞吐量
- 周转时间
- CPU利用率

### 批处理系统中的调度

1. 先来先服务
2. 最短作业优先
3. 最短剩余时间优先

### 交互式系统中的调度

1. 轮转调度
    - 时间片过短，进程切换开销过大
    - 时间片过长，相应时间过长
    - 20ms~50ms

2. 优先级调度
    - nice命令并没有人去用:)
    - 可以根据在一个时间片中占用的时间划分优先级，越少说明IO越多，优先级就越高

3. 多级队列
4. 最短进程优先
5. 保证调度
6. 彩票调度
7. 公平分享调度

### 实时系统中的调度

- 实时系统分为软实时和硬实时
- 满足所有截止时间的要求调度进程
- 调度算法可以是静态的或者动态的

## 策略和机制

- 提供一条可供进程设置优先级的系统调用
- 调度机制位于内核，调度策略由用户进程决定

## 线程调度

用户级线程和内核级线程
- 性能差别，内核级线程需要完整的上下文切换
- 用户级线程可以使用专为应用程序定制的线程调度程序

## 经典的IPC问题
- 哲学家就餐问题
- 读者-写者问题

## 小结

为了屏蔽中断的影响，操作系统提供了一个由并行运行的顺序进程组成的概念模型。