## scan

- scan 操作的迭代器比较特殊，具体可以上网搜索，这里只是做一个简单的验证
- 验证的问题，第一次返回 6，第二次 scan 时用 3，会有什么问题？
- 为了简单起见，不考虑扩容和缩容

### 测试方案
- 存入 `1 2 3 4 5 6` 6个 key
- 可以猜测并证明：slots 个数为 8（`1000`）
- 因此对应的迭代器为：  
`000 -> 100 -> 010 -> 110 -> 001 -> 101 -> 011 -> 111`  
`0 -> 4 -> 2 -> 6 -> 1 -> 5 -> 3 -> 7`
- 可以合理猜测并证明对应的哈希表结构为（虽然不是很清楚这里用的 hash 函数，但是可以通过不停 `scan cursor count 1` 来证明）
- （我 reset redis 重新按照同样的顺序存入同样的 key，不知道为啥哈希表结构不一样了，无法复现）
```
0: 4, 5
1: null
2: 2
3: 6
4: null
5: null
6: 1, 3
7: null
```
- 因此对于上边的问题，第一次返回 6 说明第一条命令很可能是 `scan 0 count 3`，当第二条命令为 `scan 3 count 3` 时，应该会返回 `cursor=0 key=6`，整个 scan 丢失了 `key=1, 3`

### 结论
- 因此对于这个问题，3 肯定在 6 的后边，那不可避免有一些 slots 没有扫描到
    - 如果这些跳过 slots 里有 key 的话会丢失一些 key
    - 但是如果没有的话就不影响结果
- 这里做了不扩容或者缩容的假设，可以知道如果扩容或者缩容应该会更复杂，但分析过程和上边相似

### 3 在 6 后边的证明
3 的二进制为 `011`，6 的二进制为 `110`，这个迭代器的算法其实是每次迭代高位加一，很明显不管 slots 为 2 的多少次方，3 都在 6 的后边（3 为 6 的二分之一，其实就是二进制右移一位）