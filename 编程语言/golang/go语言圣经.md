go 没有指针运算

聚合类型：结构体、数组
聚合类型每个成员也可以被取地址

new 返回变量地址

类型转换不是函数调用，会使语义发生变化

作用域是编译属性，生命周期是运行时的概念

- 基础类型
- 聚合类型
- 引用类型
- 布尔类型

unicode 码点：32位
range 隐身解析utf8

字符串不可修改，不变性保证了共享底层数据也是安全的

map中元素不能取址操作，因为可能重新分配地址导致之前地址无效
nil值map中存入元素会panic

无缓存的channel操作：两个goroutine做一次同步操作



# 前言
顺序进程通信（CSP）
在CSP中，程序是一组中间没有共享状态的平行运行的处理过程，它们之间使用管道进行通信和控制同步

# 入门
只有 for 一种循环语句
当一个goroutine尝试在一个channel上做send或者receive操作时，这个goroutine会阻塞在调用处，直到另一个goroutine往这个channel里写入、或者接收值，这样两个goroutine才会继续执行channel操作之后的逻辑
Go语言并不需要显式地在每一个case后写break

# 程序结构
可用内建的new函数创建变量
表达式new(T)将创建一个T类型的匿名变量，初始化为T类型的零值，然后返回变量地址，返回的指针类型为*T
只是一个语法糖
go垃圾回收用的引用计数方式，变量在堆上创建还是栈上创建由编译器决定

对于每一个类型T，都有一个对应的类型转换操作T(x)，用于将x转为T类型（译注：如果T是指针类型，可能会需要用小括弧包装T，比如(*int)(0)）

作用域是一个编译时概念，生命周期是运行时概念

声明语句对应的词法域决定了作用域范围的大小。对于内置的类型、函数和常量，比如int、len和true等是在全局作用域的，因此可以在整个程序中直接使用。任何在在函数外部（也就是包级语法域）声明的名字可以在同一个包的任何源文件中访问的。对于导入的包，例如tempconv导入的fmt包，则是对应源文件级的作用域，因此只能在当前的文件中访问导入的fmt包，当前包的其它源文件无法访问在当前源文件导入的包。还有许多声明语句，比如tempconv.CToF函数中的变量c，则是局部作用域的，它只能在函数内部（甚至只能是局部的某些部分）访问

# 基础数据类型
基础类型、复合类型、引用类型和接口类型

## 整形 浮点数 复数 布尔型 字符串 常量
有符号数的右移运算会用符号位的值填充左边空缺的bit位。因为这个原因，最好用无符号运算，这样你可以将整数完全当作一个bit位模式处理。

不变性意味如果两个字符串共享相同的底层数据的话也是安全的，这使得复制任何长度的字符串代价是低廉的

常量表达式的值在编译期计算

# 复合数据类型

## 数组 slice map 结构体
数组的长度在编译期间确定

Go语言对待数组的方式和其它很多编程语言不同，其它编程语言可能会隐式地将数组作为引用或指针对象传入被调用的函数

一个零值的slice等于nil。一个nil值的slice并没有底层数组。一个nil值的slice的长度和容量都是0，但是也有非nil值的slice的长度和容量也是0的，例如[]int{}或make([]int, 3)[3:]

哈希表通过给定的key可以在常数时间复杂度内检索、更新或删除对应的value
禁止对map元素取址的原因是map可能随着元素数量的增长而重新分配更大的内存空间，从而可能导致之前的地址无效

在实践中，遍历的顺序是随机的，每一次遍历的顺序都不相同。这是故意的，每次都使用随机的遍历顺序可以强制要求程序不会依赖具体的哈希函数实现
向一个nil值的map存入元素将导致一个panic异常

在Go语言中，所有的函数参数都是值拷贝传入的，函数参数将不再是函数调用时的原始变量
结构体必须传入指针

Go语言有一个特性让我们只声明一个成员对应的数据类型而不指名成员的名字；这类成员就叫匿名成员
结构体取值更方便

# 函数

函数类型的零值是nil。调用值为nil的函数值会引起panic错误

这就是函数值属于引用类型和函数值不可比较的原因。Go使用闭包（closures）技术实现函数值，Go程序员也把函数值叫做闭包。

当defer语句被执行时，跟在defer后面的函数会被延迟执行。

# 方法
调用方法时，接收器同样是值传递

# 接口
接口类型不会和特定的实现细节绑定在一起

当你有看到一个接口类型的值时，你不知道它是什么，唯一知道的就是可以通过它的方法来做什么

参数是一个变量；编译器隐式的获取了它的地址

我们当然不能直接对它持有的值做操作，因为interface{}没有任何方法

像Go语言这种静态类型的语言，类型是编译期的概念