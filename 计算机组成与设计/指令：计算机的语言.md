## 2.1 引言

MIPS操作数
- 32寄存器，只能对存放在寄存器中的数据执行算术操作
- 2^30个存储器字

MIPS汇编语言
- 算术
- 数据传输
- 逻辑
- 条件分支
- 无条件跳转

## 2.2 计算机硬件的操作

每条MIPS算术指令只执行一个操作，有且只有3个操作数

硬件设计3条基本原则：
1. **简单源于规整**

## 2.3 计算机硬件的操作数

MIPS中寄存器大小为32位

寄存器个数限制为32个的理由

2. **越小越快**

连续字的地址相差4，必须是4的倍数，称为对齐限制

- addi 立即数比较快，不需要从内存取数
- 支持负数，不需要减

## 2.4 有符号数和无符号数

处理溢出由编程语言、操作系统和程序决定

通过符号位表示负数的缺点
- 符号位的位置
- 不能提前得知结果的符号
- 正负0

前导位0表示正数，1表示负数（二进制补码）

## 2.5 计算机中指令的表示

MIPS字段（R型）
- op 6位，操作码
- rs 5位，第一个源操作数寄存器
- rt 5位，第二个源操作数寄存器
- rd 5位，目的寄存器
- shamt 5位，位移量
- funct 6位，功能码，指明 op 字段中操作的特定变式

取字指令需要2个寄存器和一个常数，常数被限制在32以内太不合理了

3. **优秀的设计需要适宜的折中方案**

I型，用于立即数
- op
- rs
- rt
- constant or address 16位

由于指令是32位，没有更多的空间给 rs 和 rt（5位），因此寄存器个数为32个

当今计算机基于以下两个重要准则构建
1. 指令用数的形式表示
2. 和数据一样，程序存储在存储器中，并且可以读写

## 2.6 逻辑操作

## 2.7 决策指令

- 分支
- 循环

## 2.8 计算机硬件对过程的支持

程序计数器（pc）保存当前运行指令的地址

- 临时寄存器：过程调用中不必保存
- 保留寄存器：需要保存

MIPS软件保留了一个寄存器，全局指针，简化对静态数据的访问

动态数据段习惯上称为堆

## 2.9 人机交互

表达一个字符串
1. 保留第一个位置表示长度（java）
2. 结构体中附带长度信息
3. 最后用字符标识结束（c）

## 2.10 MIPS 中 32位立即数和寻址

跳转指令是 J型指令
- 6位跳转操作码
- 26位地址

条件分支指令还有两个操作数
- 6
- 5
- 5
- 16

2^16范围太小了，利用不完2^32地址空间，所以需要一个基址寄存器

程序计数器包含当前指令的地址，是理想的选择，PC相对寻址

MIPS指令都是4字节长，因此相对寻址的时候设计为字地址，相当于18位的字节地址

寻址模式
1. 立即数寻址
2. 寄存器寻址
3. 基址寻址
4. PC相对寻址
5. 伪直接寻址

## 2.11 并行与指令：同步

不希望硬件原语被用户使用，希望被系统程序员建立同步库

方法：交换1并返回原来的值（原子交换）
- 返回1表示占用
- 0表示成功

实现：指令对（处理器的操作都在指令对之外执行），第二条指令返回值表明是否是原子操作
- 链接取数：从内存地址中取出到寄存器
- 条件存数：存数到内存地址中，若成功返回1，失败返回0。失败条件
    - 其他CPU修改了对应地址的内容
    - 当前CPU执行了其他操作（中断引起，通过判断临时寄存器是否被置0实现）

以上实现了原子交换

## 2.12 翻译并执行程序

编译器-汇编器-链接器-加载器

即时编译：将热点编译成宿主机的指令序列

## 2.13 C排序程序例子

## 2.14 数组与指针

## 2.15 高级内容：编译C语言和解释JAVA语言

## 2.16 实例：ARMv7（32位）指令集

## 2.17 实例：x86

## 2.18 实例：ARMv8（64位）

## 2.19 谬误与陷阱
