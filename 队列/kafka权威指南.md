# 第一章 初识kafka

发布订阅系统：实现解耦

- 消息
- 键（键是可选的，可作为分区依据）
- 批次：一组消息，同属于一个主题和分区，减小网络开销
- 主题：一个主题会有多个分区，只能保证分区内的顺序
- 分区：可以处于不同服务器
- 生产者
- 消费者：消费者可以自己提交偏移量元数据到zk或者kafka上
- 消费组
- broker：kafka 实例
    - 一个分区可以分配给多个 broker，选举产生首领，分区复制
    - 分区复制只用来备份以及防止首领 broker 宕机，读写只走首领
- MirrorMaker：提供多集群之间的复制

### 优点
- 多生产者
- 多消费者（以及消费组）
- 磁盘持久性
- 横向拓展
- 高性能

# 第二章 安装

数据保留策略：时间或者数据大小

# 第三章 生产者 写入数据

消息
- topic
- partition
- key
- value

序列化器 -> 分区器（先根据partition在根据key） -> 批次（可能同一topic同一partition保留多个批次在缓冲区）-> 返回主题分区信息以及偏移量

如何保证有序：
- 通过 partition 或者 key 保证写到一个分区
- max.in.flight.requests.per.connection = 1 (反例：如果不为1，批次1失败，批次2成功，批次1成功)
- 只有一个生产者？（是否需要）

# 第四章 消费者 读取数据

消费者数量不能超过分区数量，否则会被闲置

消费者加入或者退出时会发生再均衡，期间不会进行消费

一个消费者群组可以订阅多个topic

消费者群组：群组之间相互隔离

通过轮询拉取数据

发生再均衡时：
- 提交偏移量小于被处理的最后偏移量，会导致重复处理
- 手动提交偏移量避免再均衡时重复处理消息

# 第五章 深入kafka

- kafka 依赖复制来保证消息的持久性（可以设置多少个 broker ack 一个消息才算成功写入）
- 客户端重定向
- 零复制技术：不需要解析发来的消息，直接保存到文件系统之中
- 消息复制到所有副本之后才能被消费（避免出现不同安全组看到的消息不一样）
- 索引：为了支持读取某个偏移量的消息
- 清理：只保留相同 key 消息的最后一个状态

# 第六章 可靠的数据传递

kafka 保证了最少一次，如何保证仅一次传递？
- 通过保证幂等的方式处理
- 消息和偏移量放到同一个事务中，消费者启动时，读取对应偏移量

太难了。。。

# 第七章 构建数据管道

kafka connect：用于将数据库变更导进 kafka

# 第八章 跨集群数据镜像
多集群之间复制

太难了。。。

# 第九章 管理kafka

# 第十章 监控kafka

# 第十一章 流式处理

大多数数据库都提供了CDC（change data capture）
